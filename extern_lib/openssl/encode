1.对称加密(128 bit)
2.字典生成器
3.字典加密(256 * 8bit)
4.校验码计算器
//*************************************************
//设计细节
//*************************************************
>>1.对称加密(128 bit)
1.1:网络最小mbuf = 128 bit, arp = 8bit, ip = 20 bit, tcp = 20 bit. 
									128 - 48 = 80 bit
		unsigned char*4 对称加密钥匙
		unsigned int *1 校验码
		unsigned char*1 操作数(256 个操作足够多了)
		unsigned short port*1 socket端口 
		unsigned char*16 ip
									80 - (4+4+1+2+16) = 80-27 = 53 bit (必然的预留)
		字节帧布局:[arp][ip][tcp][必然预留][剩下的53 bit]

1.2:对称加密采取unsigned char 进行掩盖, 随机生产一个unsigned int 之后, 
		用unsigned char* 将其瓜分为4 个unsigned char, 实在不行就:
		unsigned char x[4], 然后再内存memcpy() 一下.  肯定可以的, 
		然后再用unsigned char*4 一组进行加密

		钥匙不用隐藏太多, 实在不行再字典加密, 然后再对钥匙进行<固定掩盖>

		{综述: <随机数掩盖> + <固定掩盖> + <字典掩盖??(可选)>}

>>2.字典生成器
2.1:理论基础: 
	unsigned char 一共就是256 个变化, [0,255]. 
	将所有数据都用unsigned char 分割之后, 
	你就可以根据一个256 * 8bit 的char encode[256] 一维数组字典进行加密. 
	加密字典和还原字典是对应的!!
	demo:
	[加密]
	原文unsigned char a;-->ascii = 97, 那你就搜索<加密字典数组>下标97,
	假设: <加密字典数组>下标97 = d, 那么a 就加密成d
	[解密]
	密文unsigned char d;-->ascii = 100, 那么你就搜索<解密字典数组>下标100,
	必然: <解密字典数组>下标100 = a, 是必然的, 这样就能还原原文a;

2.2:字典生成器:一个unsigned char [256] 数组
	以ad@n 作为定位, 必须记住ad@n 定位的位置, 无论是生成, 还是提取字典时都必须注意. 
	生成字典:
	记住定位, 写入ad@n 之后, 其它都是随机unsigned char, 
	不过填充时, 必须保证所有unsigned char 都没有相同的. 
	提取字典:
	记住定位, 然后以ad@n 开始到unsigned char [256] 数组 结尾, 顺序读. 
	然后再根据定位, 从ad@n 反向向unsigned char [256] 数组 头部, 逆向读. 
	这样ad@n 的位置就是随机的, 不一定在头部/结尾, 这样很容易让人看出来
	字典保存:
	直接存放在file 里面即可, 字典的数据最好可以全部都加一个固定掩盖, 
	比如:
		统一全部 + 7, 只能全部统一 + (某个值). 
		不能拆分两部分, 比如说前一半+1, 后一半-1, 
		因为每个数都是不同的, 值域又只有[0,255]
		加不同的数会导致产生相同值
	
	<加强: 256 bit 的字典, 你可以建成256*8 的字典, 然后, 后面的第7 个256 bit 都是随机字符,
	读取的时候, 你可以用文件截断读, 只读取前256 个字符串即可, 再从这256 个字符串中提出字典即可. 
	多些杂乱字符串, 让人分析不出你的字典的具体内容, 甚至你都不需要这么整齐的256, 长度打乱也行>


>>3.字典加密
	客户端按照<固定掩盖>+ad@n 标记来得到: 加密字典, 根据<加密字典>再自动推导出<解密字典>
	这样一个客户端就有两个字典, 这样真正开始加密解码工作的时候, 就可以下标索引, 性能也不错

	没有字典的人肯定解不开密文, 但是通过海量分析字典, 很可能会发现ad@n 标记法, 再解固定掩盖也不难. 
	<其实固定掩盖是多此一举, 这里的固定掩盖可以去掉. >
	<保存的字典不做固定掩盖, 但是提取的时候, 可以做一个固定变向 + 7, 扰乱生成的加密字典, 从而影响解密字典>

>>4.校验码计算器
4.1:基础理论: 
	客户端必须建一个unsigned int 来存储时间种子, 必须有心跳包, 
	心跳包下发就必有校验的时间种子, 时间间隔20s 以内, 
	(你可以用60s = 1,2,3,4,5,6 这种方式来屏蔽 10s, 自己对时间种子做手脚, 得到种子)
	
	客户端第一次链接之后, 下发第一次时间种子, 之后每次心跳包都附带时间种子,
	时间种子兼容一次, 也就是如果服务器秒数 = 2, 那么客户端校验数可以上传1,2 
	这样做可以防止: 1-->2 切换的时候, 有客户端跟不上更新校验数, 而被服务器踢下线. 
	但是客户端上传一个0, 表示客户端已经脱节, 超时了20 秒, 直接踢. 

	这样做你就无需担心服务器的时间是否和客户端一致, 不一致也不影响. 

4.2:实现过程demo:
	加密:
	时间unsigned int --> 固定掩盖 --> 拆分成unsigned char *4 --> 查4 次加密字典, 得到密文. 
	密文直接放到对称加密128 里面也好, 放到json 里面也好, 
	你以char 形式存放也可以, 以int 方式存放也可以, memcpy(int*, uchar*,4) 就可以强行赋值. 

	解密:
	密文 --> 字典解密 --> 将unsigned char *4 强行扭转为unsigned int --> 反固定掩盖 --> 时间

	然后你对比时间种子是否一致, 如果一致, 那么校验数就准确. 
	(当然这里可以兼容误差, 你可以相减得到abs() 绝对值 <= 1, 这样就可以兼容一个校验值丢失)




























