//111111111111111111111111111111111111111111111111111111111111111111111111
//格式测试:
//邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵
//起始日期:
//完成日期:
//************************************************************************
//修改日志:

//, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,, , ,



//<< fork() 进程技术要点 >>
//注意: fork() 等于废弃大部分cpu cache功能, 半废.
//			只有固定线程池/固定进程池, 才能最大限度地利用cpu cache功能.
//			极大地提高cpu 的计算效率.
//			但是fork() 天生就是smp 标准, 因为smp 本身就是以进程为单位的.
//
//1.fork() 内存语义: 
//	主要讲述进程fork()前,后发生的.code .bss .data .heap的变化.
//.code:
//	由于.code 是只读区域,
//	所以无论一个进程fork() 多少次, .code 都只有一份.

//.bss, .data, .heap: 
//	写时复制技术[copy-on-write], 只有真正操作写时,
//	才会先复制一份出来, 再写入到cp 出来的内存里面,
//	其它没有改写的仍然不变, 直到fork() 子进程结束.

//	fork() 一旦结束, 将复制出去的数据全部释放,
//	仅当fork() 子进程return 返回退出时(正常结束),
//	内核保留进程结束返回时的信息, 以便wait() 获取子进程的结束状态.

//	无论是exit() _exit()之类的强制退出函数,内核都不会保留<结束信息>.
//	如果你不使用fork() 两次的方式来避免僵尸进程,
//	fork() 子进程会成为僵尸进程,
//	内核没有信息, 但是要过一段时间才会真正退出.
//	fork()两次就是利用内核init进程来加速fork()孙进程的回收工作.
//	init 进程会接管所有的孤儿进程, fork() 孙进程成为孤儿之后,
//	就会被init 进程释放



//2.子父进程之间<文件描述符>共享问题:
//	实际上当子进程要操作<文件描述符>的时候,就会从父进程那里dup()出来一份.

//<子, 父进程两者>可以操作同一个<文件> or <socket>, 
//有等同的<操作能力>, 当然, 也会涉及访问冲突的问题.
//(类似于两个进程打开同一个文件的访问权限问题)

//注意:
//	子进程dup() 之后就有两个fd 描述符,
//	只有当<fd 描述符>的个数 = 0 的时候, 文件才真正关闭.
//	所以一般情况下, fork() 之后父进程都会自动关闭fd, 让子进程独占.
//	你也可以用fcntl() 修改<fd 描述符>属性, 令其close-on-exec
//	也可以在父进程显式close() 该<fd 描述符>.
//	但有两点要注意:
//	*1.子进程不需要用到的<fd 描述符>, 子, 父进程都别乱操作,
//			因为此时<fd 描述符>是读时共享, 写时赋值的,
//			子进程就算结束时, 也不要操作其它<fd 描述符>,直接退出就是,
//			如果这些<fd 描述符>并不是子进程所关心的话, 直接退出.
//			当然子进程用过的<fd 描述符>, 肯定要close() 再退出.
//			因为子进程用过之后, 就有两个<fd 描述符>了
//	*2.使用时, close() 可以, 这只表明你关闭了自己的<fd 描述符>,
//			但是如果你调用shutdown(), 那么父进程虽然没有close(),
//			但是socket 会陷入shutdown 状态,
//			如果有对端socket, 则对端socket 关闭, 即父进程还没close()
//			因为两个<fd 描述符>只是表明: 两个进程共同操作同一个文件的意思,
//			但是对端socket 只有一个. 你shutdown 会修改了文件属性状态,
//			而不是<fd 描述符> 本身属于进程内部的fd 文件操作记录<描述符>.
//
//	例如:
//		父进程在accept()之后, fork()之后, 自动关闭sfd_acc是可以的.
//		但是子进程在退出时, 多此一举操作父进程的监听fd, 就不行了.
//		对其close() 多此一举, cp 多一次内存,
//		对其shutdown() 会导致父进程监听socket 停止工作,
//		最好就是if(getpid==ppid), no就不要资源回收工作, 直接退出即可.



//3.fork()子父进程之间的竞争条件(Race Condition)--CPU优先级
//	子父进程是'不能调度'的,子父进程获取CPU优先级的机会是平均的,
//	不能像线程那样进行<单一线程优先级调度>



//4.fork(), exec(), vfork() 等api 分析:
//	fork()	比较常用, 读时共享, 写时复制
//	vfork()	是<读时共享, 写时复制>技术未出现之前的过度型api, 已经淘汰
//	exec()	linux 中并没有exec() 函数,
//	但是exec() 系列的函数却有6 个,分别是:
//		execl(),execv(),execle(),execve(),execlp(),execvp()
//	这些都是基于execve() 的变种, 会原汁原味的创建一个全新的进程.
//	system() 会调用fork(), execve(), waitpid() 等函数,
//	阻塞执行system("")里面的shell 命令


//5.process wait() - pthread join()的差别：
//	wait() 系列函数, 是父进程用来询问子进程的结束状态的函数.
//	pthread_join()系列函数, 是主进程用来询问线程结束状态的函数.
//	<< 虽然语义不一样, 但是要实现的功能也是差不多的 >>
//
//	wait()		会阻塞, 直到任意一子进程结束返回;
//	waitpid()	可以指定pid,可以阻塞可以异步,也可以指定<非子进程>的进程.
//						异步时, 如果对方还没结束则返回0
//	(注意:exit(), _exit()等函数执行的强制退出,waitpid()回失败返回-1,
//	 errno=10,因为强制退出都会导致内核信息清空,并有机会成为僵尸进程)



//6.进程状态:
//*1.孤子进程:
//	父进程结束了, 子进程还没结束. 这时候, 子进程就会被init 进程回收,
//	而init 进程的pid = 1, 也就是: 孤儿进程getppid() 永远为1.
//	只要孤儿进程结束, init 进程会第一时间消灭它. 这样就不会有僵尸进程

//*2.僵尸进程:
//	子进程的结束并不会释放所有资源,内核仍然为父进程保留最基本的进程信息:
//	其实只是内核进程表的一条记录.

//	如果父进程不对结束的子进程调用wait() 类的函数清空子进程信息,
//	那么子进程就会成为活僵尸进程.
//
//	如果子进程是exit(),_exit()等函数退出的,父进程不能对其使用wait()函数
//	但子进程仍然会成为假僵尸进程存活, 这种情况你需要fork()两次

//	根本原因: 子进程结束会产生SIGCHLD 信号,
//	如果父进程不能wait() 处理这个信号, 子进程就会成为僵尸进程.
//	如果交给init进程处理,init进程处理已经结束的进程,只有一种处理方式,
//	那就是处理SIGCHLD 信号, 释放资源.

//	debian-64 系统的僵尸进程极限: 1.1W 左右

//************************
//处理僵尸进程的意图原理:
//	如果父进程处理时间长, 子进程处理时间短,
//	那么如果父进程不 wait() 处理的话, 子进程就会成为僵尸进程,
//	但如果父进程 wait() 子进程的话, 父进程就会阻塞,
//	所以有个方法就是让自己尽快推出, 任务让子进程的子进程来处理.
//方法如下:
//	父进程一次fork()后产生一个子进程,
//	随后立即执行waitpid(子进程pid, NULL, 0)来等待子进程结束,
//	然后子进程fork()后产生孙子进程随后立即exit(0).
//	这样子进程顺利终止(父进程仅仅给子进程收尸, 并不需要子进程的返回值),
//	然后父进程继续执行.
//	这时的孙子进程由于失去了它的父进程(即是父进程的子进程),
//	将被转交给Init进程托管.
//	于是父进程与孙子进程无继承关系了, 它们的父进程均为Init,
//	Init进程在其子进程结束时会自动收尸, 这样也就不会产生僵尸进程了.
//************************


//6.多进程并发的安全性
//	子进程异常崩溃结束, 并不会影响父进程继续工作,
//	子线程就不一样了, 子线程崩溃, 会引发整个进程崩溃.
//	多进程模型实际更安全



//*******************************************************



//exit 类函数
//1.中断程序执行
void abort(void);

//2.断言
void assert();

//3.注册进程退出函数(退出函数不应该有参数和返回值)
atexit(void (*function)(void));

//4.退出程序
void exit(int status);
void _exit(int status);
//区别:
//1._exit()执行后会立即返回给内核, 
//	exit()要先执行一些清除操作, 然后将控制权交给内核.

//2.调用_exit()函数时, 
//	其会关闭进程所有的文件描述符, 清理内存, 以及其他一些内核清理函数,
//	但不会刷新流(stdin 、stdout、stderr……).

//	exit()函数是先刷新流, 再调用_exit().

//3.exit()函数与_exit()函数最大的区别就在于:
//	exit()函数在调用_exit()之前要检查文件的打开情况,
//	把文件缓冲区的内容写回文件.

//	exit() 类函数调用之后, 进程不保留任何退出信息,
//	你用什么waitpid() 函数都会失效, errno=10, 找不到该进程pid.

//x.1:abort()		引发非正常的程序终止(不清理)
//x.2:exit()		引发正常的程序终止并清理
//x.3:quick_exit() 引发正常的程序终止但不完全清理<man查不到>
//x.4:_exit()		引发正常的程序终止但不清理
//x.5:atexit()	注册一个要在调用exit() 时调用的函数
//x.6:at_quick_exit() 注册一个要在调用quick_exit时调用的函数<man查不到>

//EXIT_SUCCESS 表示程序的执行成功(宏常量)
//EXIT_FAILURE 表示程序的执行失败(宏常量)
//demo: exit(EXIT_SUCCESS);
//*******************************************************



#include <unistd.h>


//fork() 则是读时共享, 写时共享.(性能高)
//exec()与fork()不同, exec()是真的生成一个全新的程序.(性能低)


extern char **environ;

//1.exec() 函数库
//基准函数: (//成功返回0, 失败返回-1)
int execve(const char *filename,\
		char *const argv[], char *const envp[]);\
		//filename = <程序二进制码文件>存放路径

		//argv = 启动参数atgv[], argc 会自动统计出来,
		//参数列表是一个个字符串, 结尾的最后一串必须为NULL.
		//如: argv[0] = "xx", argv[1] = "xxx", argv[2] = NULL;

		//envp[] 参数用来指定新程序的<环境参数列表>,
		//也是一个字符串列表, 以NULL 结束.
		//不过格式就是： env_name=env_value 为一个字符串, 不要有空格



//派生子函数: (//成功返回0, 失败返回-1)
int execl(const char *path, const char *arg,\
		...  /* (char	*) NULL */);
int execlp(const char *file, const char *arg,\
		...  /* (char	*) NULL */);
int execle(const char *path, const char *arg,\
		...  /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);

//以上所有这些函数均构建于execve() 之上, 
//只是在为新程序指定:<程序名>,<参数列表>以及<环境变量>的方式上有所不同而已



