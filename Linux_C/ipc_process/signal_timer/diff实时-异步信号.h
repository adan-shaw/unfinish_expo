//111111111111111111111111111111111111111111111111111111111111111111111111
//格式测试:
//邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵
//起始日期:
//完成日期:
//************************************************************************
//修改日志:

//, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,, , ,



/*
1.改变信号处置(函数)
	signal()异步信号：
		简单, 可移植性高(旧式);
		
		但是具体每种unix的实现方式都不一样, 可控性太低;
		
		异步信号, 可能会被覆盖, 可能会被丢失;
		
		有一个信号位可等待(容纳一个候选等待signal信号),
		旧式信号signal 可以有: 正在执行的信号和一个等待信号.



	sigaction()实时信号:
		复杂, 跨平台可能存在问题(posix);
		
		但是可控性高, 所有unix 都根据标准来做这个函数;
		
		实时信号, 进程并没有信号列表的东西, 不会将信号存储起来,
		实时信号的意思就是: 收到信号之后, 中断, 马上执行.
		
		进程可以'选择执行'or'屏蔽实时信号',
		但一旦接受, 就要以最快的速度执行信号处理函数,
		不存在信号列表, 不存在等待信号.
		
		用sigqueue() 发送实时信号的时候, 需要提供pid,
		一旦信号发出, 如果受体pid 进程接收信号, 则马上执行, 
		如果受体pid 进程不接收信号, 则马上丢弃.
		
		实时信号都是马上转发&&执行的, 并不会在内核存在很久.
		(内核转发损耗忽略不计)



2.发布时, 屏蔽不需要的异步信号.
	旧式信号signal() 因为可靠性太低,
	你可以在产品发布之后, 全部屏蔽.
	(防止进程受'旧式信号signal()'干扰).
	
	当然调试的时候你不能屏蔽, 
	但是发布的时候, 全部屏蔽剩下9 and 19 是正常的.
	(9 和19 是关键信号, 不能完全屏蔽)



3.实时定时器
	如果你真的想做定时器,那你肯定也希望是实时信号,进程收到信号后马上去执行.
	那么你可以用sigaction() + setitimer() 来注册定时器,
	sigaction()可以将1-64的信号都重新注册一次,让1-31信号都变成实时信号.

	所以有sigaction() + 
		ITIMER_REAL			----	SIGALRM
		ITIMER_VIRTUAL	----	SIGVTALRM
		ITIMER_PROF			----	SIGPROF
	组成新的实时信号, 然后就可以造成实时定时器了
	如果你不用sigaction将<定时器信号>重新注册,那么<定时器信号>就不是实时的


ITIMER_REAL:
	给定一个指定的时间间隔, 按照实际的时间来减少这个计数, 
	当时间间隔为0的时候发出SIGALRM信号. 

ITIMER_VIRTUAL:
	给定一个时间间隔, 当进程执行的时候才减少计数, 
	时间间隔为0的时候发出SIGVTALRM信号. 

ITIMER_PROF:
	给定一个时间间隔, 当进程执行或者是系统为进程调度的时候, 
	减少计数, 时间到了, 发出SIGPROF信号, 
	这个和TIMER_VIRTUAL联合, 常用来计算系统内核时间和用户时间. 
*/




