//111111111111111111111111111111111111111111111111111111111111111111111111
//格式测试:
//邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵
//起始日期:
//完成日期:
//************************************************************************
//修改日志:
//	2019-05-13: 新增'tty 文本标准格式'风格
//, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,, , ,








/*
//2.io 复用
	io 复用只是一种反映io fd 状态的机制, 本质上属于fd stat 的一部分,
	跟同步和异步完全没有关系, 虽然你也可以用io 复用来实现异步操作.

	io 复用的异步操作主要是为了间隔慢速的设备和告诉的CPU 之间的时间差,
	让设备完成io 之后才通知cpu, 这样可以节省cpu 时间.
	检索io 状态是否繁忙, 不忙就工作马上执行任务, 忙就马上返回or 马上返回并继续监听

	而异步操作(内存缓冲型), 实际上是一种数据收集机制, 属于批量集中操作的类型.
*/





//3.阻塞
//操作的<目标任务完成>才返回, 叫阻塞操作, 阻塞操作函数
//操作的<目标任务未完成>就返回, 叫非阻塞操作, 非阻塞操作函数





//4.同步/异步. <同步和异步>典型案例: 是io 缓存冲刷.
/*
异步:
	std:cin, stdcout, 都是属于异步, 读写磁盘数据时, 实际先操作对应的进程内存块,
	由系统统一冲刷或者fflush() 手动冲刷数据到磁盘, 这样的方式都属于异步

同步:
	open() 直接打开设备读写, 直接写到disk 里面, 无缓存冲刷, 属于同步读写
*/





