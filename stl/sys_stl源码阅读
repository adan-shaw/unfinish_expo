如何查看c++ stl 源代码？？

1.路径/usr/include/c++/6.3.0 下面有包含的, 外层声明. 
	这不是完整的stl, 反倒是部分高层的stl 的实现指引, 比如说:
	queue 依赖deque 来实现. deque 以来vector 来实现. 
	所以queue 基本上要包含以上两个头文件. 



2.路径/usr/include/c++/6.3.0/bits 下面, 所有stl_ 前缀的文件,
	才是stl 容器的具体实现文件, 都是类声明, 因为c++ 就是一个类,
	而且类实现都已经在类声明中定义了, 既是声明, 也是定义



3.c++ 的源文件实现, 主要是以.h 头文件来实现的. 
	其实.h 和.cpp 实现都可以吧, 但是c++ 主要是类声明, 
	所以类声明可以全部定义在.h 文件里面, 
	所以c++ 实现可以没有.cpp 文件.
	尤其是编译器, 为了便捷, 已经全部声明在.h 文件里面了. 

	当然, 如果你自己写c++ 类, 
	没有很大的把握和很精简的代码, 很可靠的实验数据,
	你也不要将实现定义在.h 文件里面



4.迭代器初始化类型之后, 
	begin() 主要指向首地址的值, end() 主要是以<类型间距>,
	指向末位地址的值, 迭代器本质上也是指针, 但是值表达上面有些差异.
	所以, 在遍历循环的时候就有:
	set<int>::iterator it;
	for(it = x2.begin(); it != x2.end(); *it++)
		printf("%d\n", *it);
	如果set 里面有10 个int 元素, 那么x2.end() 就会是10. 
	但是x2.begin() 却会是第一个元素的值.
	begin() 指向值, end() 指向终结位置.

	那么你取首地址的值, 就是: it=x2.begin(); 即可
	如果要取最后一个元素的值, 就是:
	it=x2.begin();
	it+=x2.end();
	printf("%d\n", *it);

	另外, 迭代器的实现, 有可能还是共享变量的方式, static？？ 这个未知

	正是因为.end() 不能表示最后一个元素, 所以才有rbegin() 反向索引的存在. 

	因此, end() 都是不能当成值索引来做的.

//question--已解决,迭代器指向end()是没有意义的,如果反向查找,请用rbegin()
//stl 就是为了解决反向查找的问题, 才引入begin(), rbegin() 两个索引的.
//end() 只是指引内存区域, 并不代表元素值地址!!
//同时反向索引需要用: set<int>::reverse_iterator rit; 反向迭代器

