< stl的线程安全 >

一般说来, stl对于多线程的支持仅限于下列两点：(貌似Effective STL中有描述)
1.多个读取者是安全的. 即多个线程可以同时读取一个容器中的内容. 
	即此时多个线程调用‘不涉及到写操作的接口’都可以find, begin, end等.


2.对'不同容器'的'多个写入者'是安全的, 即多个线程对不同容器的同时写入合法. 
	(这里证明了stl 容器并'没有用任何全局变量来实现', 全部都是局部容器, 
	 如果不同的容器对象同时写入都实现不到, 
	 那么就是这个stl 容器有全局变量/静态变量来实现的)


	但是对于'同一容器'当有线程写,有线程读时,如何保证正确?
	需要程序员自己来控制, 比如：
	线程A读容器某一项时, 线程B正在移除该项. 
	这会导致一下无法预知的错误. 
	通常的解决方式是用开销较小的临界区(CRITICAL_SECTION)来做同步. 


以下列方式同步基本上可以做到线程安全的容器
(就是在有写操作的情况下仍能保证安全). 
1.每次调用容器的成员函数的期间需要锁定. 
2.每个容器容器返回迭代器的生存期需要锁定. 
3.每个容器在调用算法的执行期需要锁定. 





和小罗的关于task_server的多线程安全的交流:
	是这样的, 当你调用map的任何接口时, 
	比如 end(), begin(), find()等时, 可能会返回一个iterator, 
	如果有别的线程正在修改这个map, 你的iterator就变得无效了, 
	再用这个iterator行为就可能出问题. 
	或者在find()函数内部, 会访问到map内部的红黑树的数据结构, 
	而这个红黑树是有可能被别的线程调整的
	(比如别的现在往map中插入一个不存在的记录). 
	所以, 是危险的.


	总结: 多线程stl 访问一般都要加互斥锁, 使用迭代器访问的stl 容器, 
			 使用迭代器时也要加锁, 否则迭代器可能<失效>




